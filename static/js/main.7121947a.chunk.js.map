{"version":3,"sources":["logo.svg","PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/astar1.js","algorithms/bfs.js","algorithms/dfs.js","algorithms/bidirectional.js","algorithms/dfsMaze.js","algorithms/RecursiveDivisionMaze.js","PathfindingVisualizer/PathfindingVisualizer.jsx","algorithms/binaryTreeMaze.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","f","g","h","distance","isVisited","otherVisited","previousNode","previousNodeStart","previousNodeEnd","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","console","log","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","astar","heuristic","a","b","Math","abs","nodesInShortestPathOrder","getUnvisitedNeighborsStart","getUnvisitedNeighborsEnd","dfsMaze","i","j","Grid","slice","randRow","floor","random","randCol","recursion","r","c","randDirs","dir","arra1","temp","index","ctr","shuffle","generateRandomDirections","recursiveDivMaze","bias","start","finish","walls","createVisited","passages","recursiveDivMazeHelper","iStart","iEnd","jStart","jEnd","horzStart","horzEnd","vertStart","vertEnd","width","canMakeVertWall","canMakeHorzWall","x","lineOrientation","vertWidth","horzHeight","visited","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","path","t1","PathfindingVisualizer","state","mouseIsPressed","moveStart","moveEnd","mazeType","algo","algoInfo","resetGrid","bind","visualizeDijkstra","handleMazeChange","handleAlgoChange","clearPath","getInitialGrid","setState","newGrid","newNode","getNewGridWithWallToggled","getNewGridMovingStart","getNewGridMovingEnd","event","string","target","value","d","Date","getTime","visualizeAstar","visualizeBFS","visualizeDFS","visualizeBiDi","height","n1","prob","node1","n2","node2","n3","binaryTreeMaze","setTimeout","animateShortestPath","d1","t2","p","c1","document","getElementById","JSON","parse","stringify","classList","remove","currentRow","n","createNode","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","getNodesInShortestPathOrderAstar","q","qNode","unVisitedNeighbors","BFS","getNodesInShortestPathOrderBFS","Isfound","pop","DFS","getNodesInShortestPathOrderDFS","q1","q2","qNode1","qNode2","currentNode1","currentNode2","unVisitedNeighborsStart","neighborS","unVisitedNeighborsEnd","neighborE","biDirectional","onClick","onChange","visualizeAlgo","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"wJAAAA,EAAOC,QAAU,IAA0B,kC,4LCItBC,G,6KACT,IAAD,EAoBHC,KAAKC,MAlBPC,EAFK,EAELA,IACAC,EAHK,EAGLA,SACAC,EAJK,EAILA,QACAC,EALK,EAKLA,OACAC,EANK,EAMLA,YACAC,EAPK,EAOLA,aACAC,EARK,EAQLA,UACAC,EATK,EASLA,IAYIC,GArBC,EAULC,EAVK,EAWLC,EAXK,EAYLC,EAZK,EAaLC,SAbK,EAcLC,UAdK,EAeLC,aAfK,EAgBLC,aAhBK,EAiBLC,kBAjBK,EAkBLC,gBAGqBhB,EACnB,cACAC,EACA,aACAC,EACA,YACA,IAEJ,OACE,yBACEe,GAAE,eAAUX,EAAV,YAAiBP,GACnBmB,UAAS,eAAUX,GACnBJ,YAAa,kBAAMA,EAAYG,EAAKP,IACpCK,aAAc,kBAAMA,EAAaE,EAAKP,IACtCM,UAAW,kBAAMA,EAAUC,EAAIP,U,GApCLoB,c,OCA3B,SAASC,EAASC,EAAMC,EAAWC,GACxC,IAAMC,EAAsB,GAC5BF,EAAUX,SAAW,EAErB,IADA,IAAMc,EA4DR,SAAqBJ,GACnB,IADyB,EACnBK,EAAQ,GADW,cAEPL,GAFO,IAEzB,2BAAwB,CAAC,IAAD,EAAbf,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAdqB,EAAa,QACtBD,EAAME,KAAKD,IAFS,gCAFC,8BAOzB,OAAOD,EAnEgBG,CAAYR,GAC1BI,GAAgBA,EAAeK,OAAO,GAAG,CAChDC,EAAoBN,GAEpBO,QAAQC,IAAIR,EAAeK,OAAO,UAClC,IAAMI,EAAcT,EAAeU,QAInC,GAFAH,QAAQC,IAAIC,EAAYvB,SAAS,SAASuB,EAAYtB,UAAU,IAAIsB,EAAYhC,SAE5EgC,EAAYhC,SAAQgC,EAAYtB,UAApC,CAIA,GAAIsB,EAAYvB,WAAayB,IAEzB,OADEJ,QAAQC,IAAI,oBACPT,EAKX,GAJAU,EAAYtB,WAAY,EAExBoB,QAAQC,IAAI,UACZT,EAAoBI,KAAKM,GACrBA,IAAgBX,EAChB,OAAOC,EACXa,EAAyBH,EAAab,IAIvC,OADDW,QAAQC,IAAI,WAAWT,EAAoBM,QACnCN,EAIV,SAASO,EAAoBN,GAC3BO,QAAQC,IAAI,WACZR,EAAea,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAM5B,SAAW6B,EAAM7B,YAG/D,SAAS0B,EAAyBV,EAAMN,GACtC,IAD4C,EACtCoB,EASR,SAA+Bd,EAAMN,GACnC,IAAMqB,EAAY,GACX3C,EAAY4B,EAAZ5B,IAAKO,EAAOqB,EAAPrB,IACRA,EAAM,GAAGoC,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IAEtCO,EAAMe,EAAKS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACpDA,EAAM,GAAG2C,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACxCA,EAAMsB,EAAK,GAAGS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IAK7D,OAAO2C,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAShC,YAAYgC,EAAS1C,UArBxC2C,CAAsBlB,EAAMN,GADX,cAErBoB,GAFqB,IAE5C,2BAA2C,CAAC,IAAjCG,EAAgC,SACrCA,EAAS1C,QAAQ0C,EAASjC,SAAUgB,EAAKhB,SAAS,IACrDiC,EAASjC,SAAWgB,EAAKhB,SAAW,EACrCqB,QAAQC,IAAI,gBACTW,EAAS9B,aAAea,IANe,+BCtCvC,SAASmB,EAAMzB,EAAMC,EAAWC,GACnC,IAAMC,EAAsB,GAC3BF,EAAUb,EAAE,EACZa,EAAUZ,EAAEqC,EAAUzB,EAAUC,GAChCD,EAAUd,EAAEc,EAAUb,EAAEa,EAAUZ,EAClCsB,QAAQC,IAAI,aACb,IAAMR,EAwDR,SAAqBJ,GACnB,IADyB,EACnBK,EAAQ,GADW,cAEPL,GAFO,IAEzB,2BAAwB,CAAC,IAAD,EAAbf,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAdqB,EAAa,QACtBD,EAAME,KAAKD,IAFS,gCAFC,8BAOzB,OAAOD,EA/DgBG,CAAYR,GAEnC,IADAW,QAAQC,IAAIR,EAAeK,QAClBL,EAAeK,QAAQ,CAC9BC,EAAoBN,GACpB,IAAMS,EAAcT,EAAeU,QAEnC,IAAID,EAAYhC,OAAhB,CAIA,GADG8B,QAAQC,IAAIC,EAAY1B,EAAE,IAAI0B,EAAYzB,EAAE,IAAIyB,EAAYxB,GAC3DwB,EAAY1B,IAAM4B,IAElB,OADEJ,QAAQC,IAAIT,EAAoBM,QAC3BN,EAGX,GAFAU,EAAYtB,WAAY,EACxBY,EAAoBI,KAAKM,GACrBA,IAAgBX,EAAY,OAAOC,EACvCa,EAAyBH,EAAab,EAAKE,IAE7C,OAAOC,EAGT,SAASO,EAAoBN,GAC3BA,EAAea,MAAK,SAACC,EAAOC,GACvB,OAAID,EAAM/B,IAAIgC,EAAMhC,EACd+B,EAAM7B,EAAI8B,EAAM9B,EAChB6B,EAAM/B,EAAEgC,EAAMhC,KAI3B,SAAS6B,EAAyBV,EAAMN,EAAKE,GAC3C,IADuD,EACjDkB,EAWR,SAA+Bd,EAAMN,GACnC,IAAMqB,EAAY,GACX3C,EAAY4B,EAAZ5B,IAAKO,EAAOqB,EAAPrB,IACRA,EAAM,GAAGoC,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IAEtCO,EAAMe,EAAKS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACpDA,EAAM,GAAG2C,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACxCA,EAAMsB,EAAK,GAAGS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IAK7D,OAAO2C,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAShC,YAAYgC,EAAS1C,UAvBxC2C,CAAsBlB,EAAMN,GADA,cAEhCoB,GAFgC,IAEvD,2BAA2C,CAAC,IAAjCG,EAAgC,QACtCA,EAASpC,GAAGmB,EAAKnB,EAAE,IACrBoC,EAASnC,EAAEkB,EAAKlB,EAAE,EACnBmC,EAASlC,EAAEqC,EAAUH,EAASrB,GAC9BqB,EAASpC,EAAEoC,EAASnC,EAAEmC,EAASlC,EAC/BkC,EAAS9B,aAAea,IAP6B,+BAsCzD,SAASoB,EAAUC,EAAEC,GAGnB,OADMC,KAAKC,IAAIH,EAAE1C,IAAI2C,EAAE3C,KAAK4C,KAAKC,IAAIH,EAAEjD,IAAIkD,EAAElD,KCvCjD,SAAS8C,EAAsBlB,EAAMN,GACjC,IAAMqB,EAAY,GACX3C,EAAY4B,EAAZ5B,IAAKO,EAAOqB,EAAPrB,IAMZ,OALIA,EAAM,GAAGoC,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACtCO,EAAMe,EAAKS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACpDA,EAAM,GAAG2C,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACxCA,EAAMsB,EAAK,GAAGS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IAEtD2C,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAShC,YAAYgC,EAAS1C,UChBvE,SAAS2C,EAAsBlB,EAAMN,GACjC,IAAMqB,EAAY,GACX3C,EAAY4B,EAAZ5B,IAAKO,EAAOqB,EAAPrB,IAOZ,OANIP,EAAM,GAAG2C,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACxCA,EAAMsB,EAAK,GAAGS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACzDO,EAAM,GAAGoC,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACtCO,EAAMe,EAAKS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IAGjD2C,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAShC,YAAYgC,EAAS1C,UCvCvE,IAAIkD,EAA2B,GA0G/B,SAASC,EAA2B1B,EAAMN,GAGtC,IAAMqB,EAAY,GACX3C,EAAY4B,EAAZ5B,IAAKO,EAAOqB,EAAPrB,IAMZ,OALIA,EAAM,GAAGoC,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACtCO,EAAMe,EAAKS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACpDA,EAAM,GAAG2C,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACxCA,EAAMsB,EAAK,GAAGS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IAEtD2C,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAShC,YAAYgC,EAAS1C,UAErE,SAASoD,EAAyB3B,EAAMN,GAGtC,IAAMqB,EAAY,GACX3C,EAAY4B,EAAZ5B,IAAKO,EAAOqB,EAAPrB,IAMZ,OALIA,EAAM,GAAGoC,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACtCO,EAAMe,EAAKS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,EAAM,GAAGP,IACpDA,EAAM,GAAG2C,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IACxCA,EAAMsB,EAAK,GAAGS,OAAS,GAAGY,EAAUd,KAAKP,EAAKf,GAAKP,EAAM,IAEtD2C,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAAS/B,eAAe+B,EAAS1C,U,MClInE,SAASqD,EAAQlC,EAAKC,EAAUC,GAGrC,IAAI,IAAIiC,EAAE,EAAEA,EAAEnC,EAAKS,OAAO0B,IACvB,IAAI,IAAIC,EAAE,EAAEA,EAAEpC,EAAK,GAAGS,OAAO2B,IAG5BpC,EAAKmC,GAAGC,GAAGvD,OAAQmB,EAAKmC,GAAGC,KAAKnC,GAAWD,EAAKmC,GAAGC,KAAKlC,EAU5D,IACMmC,EAAKrC,EAAKsC,QAEXC,EAAQV,KAAKW,MAAMX,KAAKY,UAAUzC,EAAKS,OAAO,IAC9CiC,EAAQb,KAAKW,MAAMX,KAAKY,UAAUzC,EAAK,GAAGS,OAAO,IAQpD,OAPCE,QAAQC,IAAIyB,GACNA,GACJ1B,QAAQC,IAAI,MACVyB,IACDA,EAAKE,GAASG,GAAS7D,QAAO,GAapC,SAAS8D,EAAU3C,EAAK4C,EAAEC,GAIxB,IAFA,IAAMC,EA4EV,WAEE,IADA,IAAMC,EAAI,GACDZ,EAAI,EAAGA,EAAI,EAAGA,IAClBY,EAAIxC,KAAK4B,EAAI,GAGnB,OAzBC,SAAiBa,GACf,IACIC,EACAC,EAFAC,EAAMH,EAAMvC,OAKhB,KAAO0C,EAAM,GAETD,EAAQrB,KAAKW,MAAMX,KAAKY,SAAWU,GAEnCA,IAEAF,EAAOD,EAAMG,GACbH,EAAMG,GAAOH,EAAME,GACnBF,EAAME,GAASD,EAEnB,OAAOD,EASHI,CAAQL,GAlFKM,GAERlB,EAAI,EAAGA,EAAIW,EAASrC,OAAQ0B,IAEjC,OAAOW,EAASX,IAChB,KAAK,EAED,GAAIS,EAAI,GAAK,EACT,SAEA5C,EAAK4C,EAAI,GAAGC,GAAGhE,SACfmB,EAAK4C,EAAE,GAAGC,GAAGhE,QAAO,EACpBmB,EAAK4C,EAAE,GAAGC,GAAGhE,QAAO,EACpB8D,EAAU3C,EAAK4C,EAAI,EAAGC,IAE1B,MACJ,KAAK,EAED,GAAIA,EAAI,GAAK7C,EAAK,GAAGS,OAAS,EAC1B,SAEAT,EAAK4C,GAAGC,EAAI,GAAGhE,SACfmB,EAAK4C,GAAGC,EAAI,GAAGhE,QAAO,EACtBmB,EAAK4C,GAAGC,EAAI,GAAGhE,QAAO,EACtB8D,EAAU3C,EAAK4C,EAAGC,EAAI,IAE1B,MACJ,KAAK,EAED,GAAID,EAAI,GAAK5C,EAAKS,OAAS,EACvB,SAEAT,EAAK4C,EAAI,GAAGC,GAAGhE,SACfmB,EAAK4C,EAAE,GAAGC,GAAGhE,QAAO,EACpBmB,EAAK4C,EAAE,GAAGC,GAAGhE,QAAO,EACpB8D,EAAU3C,EAAK4C,EAAI,EAAGC,IAE1B,MACJ,KAAK,EAED,GAAIA,EAAI,GAAK,EACT,SAEA7C,EAAK4C,GAAGC,EAAI,GAAGhE,SACfmB,EAAK4C,GAAGC,EAAI,GAAGhE,QAAO,EACtBmB,EAAK4C,GAAGC,EAAI,GAAGhE,QAAO,EACtB8D,EAAU3C,EAAK4C,EAAGC,EAAI,KA3DlCF,CAAUN,EAAKE,EAAQG,GAChBL,EC7BV,IAAIrC,EAAK,GACH,SAASsD,EAAiBjB,EAAKkB,EAAKC,EAAMC,GAG3CzD,EAAKqC,EAAKC,QAEf,IAAK,IAAIH,EAAI,EAAGA,EAAInC,EAAKS,OAAQ0B,IAChC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,EAAK,GAAGS,OAAQ2B,IAC1B,GAALD,GAAe,GAALC,GAAUD,GAAMnC,EAAKS,OAAS,GAAM2B,GAAMpC,EAAK,GAAGS,OAAS,IACxET,EAAKmC,GAAGC,GAAGvD,QAAO,GAKrB,IAAI6E,EAAQC,EAAc3D,GACtB4D,EAAWD,EAAc3D,GAM7B,OAMD,SAAS6D,EAAuBC,EAAQC,EAAMC,EAAQC,EAAMC,EAAWC,EAASC,EAAWC,EAASX,EAAOE,EAAUL,EAAKC,EAAMC,GAC/H,IACIa,EAAQL,EAAOD,EAAS,EACxBO,EAAmBF,EAAUD,GAAc,EAC3CI,EAAmBL,EAAUD,GAAc,EAC9C,GAJYH,EAAOD,EAAS,EAIf,GAAKQ,EAAQ,IAAMC,GAAmBC,EACnD,OAGD,IAAIC,EAAI5C,KAAKW,MAAsB,GAAhBX,KAAKY,UACxB,GAAY,YAARc,EACH,IAAImB,EAAkBD,EAAI,EAAI,WAAa,kBACrC,GAAY,cAARlB,EACNmB,EAAkBD,EAAI,EAAI,WAAa,kBAEvCC,EAAkBD,EAAI,EAAI,WAAa,aAI5C,GAAuB,YAAnBC,EAA8B,CACjC,IAAIC,EAAYN,EAAUD,EAAY,EAClC1B,EAAUb,KAAKW,MAAMX,KAAKY,SAAWkC,GAAaP,EACtD,GAAIR,EAASE,GAAQpB,GACpB,IAAIH,EAAUuB,OACR,GAAIF,EAASG,GAAMrB,GACrBH,EAAUwB,OAEVxB,EAA4C,GAAjCV,KAAKW,MAAsB,EAAhBX,KAAKY,UAAsBqB,EAAQC,EAG9D,IAAK,IAAI5B,EAAI2B,EAAQ3B,GAAK4B,EAAM5B,IAC/B,IAAKyB,EAASzB,GAAGO,GACjB,GAAIP,GAAKI,EAER,IAAK,IAAIH,EAAIM,EAAU,EAAGN,GAAKM,EAAU,EAAGN,IAC3CwB,EAASzB,GAAGC,IAAK,OAIdpC,GACDW,QAAQC,IAAI,QAAQuB,EAAE,IAAIO,GAEzB1C,EAAKmC,GAAGO,KAAWc,GAAQxD,EAAKmC,GAAGO,KAAWe,IACjDzD,EAAKmC,GAAGO,GAAS7D,QAAO,GAG3BgF,EAAuBC,EAAQC,EAAMC,EAAStB,EAAU,EAAIwB,EAAWC,EAASC,EAAY1B,EAAU,EAAIgB,EAAOE,EAASJ,EAAMC,GAChII,EAAuBC,EAAQC,EAAOrB,EAAU,EAAIuB,EAAMC,EAAWC,EAAUzB,EAAU,EAAI2B,EAASX,EAAOE,EAASJ,EAAMC,OAGrH,CACP,IAAImB,EAAaT,EAAUD,EAAY,EACnC3B,EAAUV,KAAKW,MAAMX,KAAKY,SAAWmC,GAAcV,EACvD,GAAIN,EAASrB,GAASyB,GACjBtB,EAAUsB,OACR,GAAIJ,EAASrB,GAAS0B,GACxBvB,EAAUuB,OAEVvB,EAA4C,GAAjCb,KAAKW,MAAsB,EAAhBX,KAAKY,UAAsBuB,EAAQC,EAG9D,IAAS7B,EAAI4B,EAAQ5B,GAAK6B,EAAM7B,IAC/B,IAAKwB,EAASrB,GAASH,GACvB,GAAIA,GAAKM,EAER,IAASP,EAAII,EAAU,EAAGJ,GAAKI,EAAU,EAAGJ,IAC3CyB,EAASzB,GAAGC,IAAK,OAIXpC,GACJW,QAAQC,IAAI,SACCZ,EAAKuC,GAASH,KAAKoB,GAAQxD,EAAKuC,GAASH,KAAKqB,IAC7DzD,EAAKuC,GAASH,GAAGvD,QAAO,GAK3BgF,EAAuBC,EAASvB,EAAU,EAAIyB,EAAQC,EAAMC,EAAY3B,EAAU,EAAI6B,EAAWC,EAASX,EAAOE,EAASJ,EAAMC,GAChII,EAAwBtB,EAAU,EAAIwB,EAAMC,EAAQC,EAAO1B,EAAU,EAAI4B,EAASC,EAAWC,EAASX,EAAOE,EAASJ,EAAMC,GAE7H,OA5FAI,CAAuB,EAAI7D,EAAKS,OAAS,EAAI,EAAIT,EAAK,GAAGS,OAAS,EAAI,EAAIT,EAAKS,OAAS,EAAI,EAAIT,EAAK,GAAGS,OAAS,EAAIiD,EAAOE,EAAUL,EAAKC,EAAMC,GAEhJzD,EAAKwD,EAAMvE,KAAKuE,EAAM9E,KAAKG,QAAO,EAClCmB,EAAKyD,EAAOxE,KAAKwE,EAAO/E,KAAKG,QAAO,EAE9BmB,EA2FR,SAAS2D,EAAc3D,GAGtB,IAFA,IAAI6E,EAAU,GAEL1C,EAAI,EAAGA,EAAInC,EAAKS,OAAQ0B,IAAI,CAEpC,IADA,IAAIlD,EAAM,GACDmD,EAAI,EAAGA,EAAIpC,EAAK,GAAGS,OAAQ2B,IAC/BpC,EAAKmC,GAAGC,GAAGvD,OACdI,EAAIsB,MAAK,GAETtB,EAAIsB,MAAK,GAGXsE,EAAQtE,KAAKtB,GAEd,OAAO4F,EC9GR,IAAIC,EAAiB,GACjBC,EAAiB,GACjBC,EAAkB,GAClBC,EAAkB,GAClBJ,EAAQ,GACRK,EAAK,GACLC,EAAG,EAEcC,E,kDACnB,aAAe,IAAD,8BACZ,gBACKC,MAAQ,CACXrF,KAAM,GACNsF,gBAAgB,EAChBC,WAAW,EACXC,SAAS,EACTC,SAAU,aACVC,KAAK,GACLC,SAAS,GACT/E,IAAI,yCAEN,EAAKgF,UAAU,EAAKA,UAAUC,KAAf,gBACf,EAAKC,kBAAkB,EAAKA,kBAAkBD,KAAvB,gBACvB,EAAKE,iBAAiB,EAAKA,iBAAiBF,KAAtB,gBACrB,EAAKG,iBAAiB,EAAKA,iBAAiBH,KAAtB,gBACtB,EAAKI,UAAU,EAAKA,UAAUJ,KAAf,gBAhBJ,E,gEAuBZ,IAAM7F,EAAOkG,IACb1H,KAAK2H,SAAS,CAACnG,W,sCAKDf,EAAKP,GAEnB,GAAIoG,IAAiB7F,GAAK8F,IAAiBrG,EACzC,CACE,IAAM0H,EAAU5H,KAAK6G,MAAMrF,KAAKsC,QAC1BhC,EAAO8F,EAAQnH,GAAKP,GACpB2H,EAAO,2BACR/F,GADQ,IAGX1B,SAAS,IAQV,OAJDwH,EAAQnH,GAAKP,GAAO2H,OAEnB7H,KAAK2H,SAAS,CAACnG,KAAMoG,EAAQb,WAAW,EAAKD,gBAAgB,IAI/D,GAAGN,IAAkB/F,GAAKgG,IAAkBvG,EAC5C,CAEC,IAAM0H,EAAU5H,KAAK6G,MAAMrF,KAAKsC,QAC1BhC,EAAO8F,EAAQnH,GAAKP,GACpB2H,EAAO,2BACR/F,GADQ,IAGX3B,UAAU,IAOX,OAHDyH,EAAQnH,GAAKP,GAAO2H,OAEnB7H,KAAK2H,SAAS,CAACX,SAAS,EAAKF,gBAAgB,IAIlD,IAAMc,EAAUE,EAA0B9H,KAAK6G,MAAMrF,KAAMf,EAAKP,GAChEF,KAAK2H,SAAS,CAACnG,KAAMoG,EAASd,gBAAgB,M,uCAK/BrG,EAAKP,GAEpB,IAAIF,KAAK6G,MAAME,YAAW/G,KAAK6G,MAAMG,SAAUhH,KAAK6G,MAAMC,eAA1D,CAEA,IAAMc,EAAUE,EAA0B9H,KAAK6G,MAAMrF,KAAMf,EAAKP,GAChEF,KAAK2H,SAAS,CAACnG,KAAMoG,O,oCAGTnH,EAAIP,GAEhB,GAAGF,KAAK6G,MAAME,UACZ,CAEI,IAAMa,EAAUG,EAAsB/H,KAAK6G,MAAMrF,KAAMf,EAAKP,GAC3DF,KAAK2H,SAAS,CAACnG,KAAMoG,IAI1B,GAAG5H,KAAK6G,MAAMG,QACd,CAEI,IAAMY,EAAUI,EAAoBhI,KAAK6G,MAAMrF,KAAMf,EAAKP,GACxDF,KAAK2H,SAAS,CAACnG,KAAMoG,IAM7B5H,KAAK2H,SAAS,CAACZ,WAAU,EAAMC,SAAQ,EAAMF,gBAAgB,M,uCAG7CmB,GAEZjI,KAAKyH,YAEN,IAAIS,EAAO,GACX,OAAOD,EAAME,OAAOC,OAErB,IAAK,uBACDF,EAAO,qEACP,MAEJ,IAAK,YACAA,EAAO,sDACV,MAEF,IAAK,uBACDA,EAAO,uEACT,MAEF,IAAK,qBACHA,EAAO,mEACP,MAEF,IAAK,uBACHA,EAAO,mEAOPlI,KAAK2H,SAAS,CAACT,KAAKe,EAAME,OAAOC,MAAMjB,SAASe,M,sCAMpD,IAAIG,EAAE,IAAIC,KAGV,OAFA3B,EAAG0B,EAAEE,UAEEvI,KAAK6G,MAAMK,MAEhB,IAAK,uBACDlH,KAAKsH,oBACL,MAEJ,IAAK,YACHtH,KAAKwI,iBACL,MAEF,IAAK,uBACHxI,KAAKyI,eACL,MAEF,IAAK,qBACHzI,KAAK0I,eACL,MAEF,IAAK,uBACH1I,KAAK2I,mB,uCAYMV,GAGf9F,QAAQC,IAAI6F,EAAME,OAAOC,OACzBpI,KAAKoH,YAEL,IAAMvD,EAAK6D,IAGI1H,KAAK6G,MAAXrF,KACR,OAAOyG,EAAME,OAAOC,OAGf,IAAK,iBAGH,IAAMR,ECvNX,SAAwBpG,EAAKC,EAAUC,GAK3C,IAJA,IAAIkH,EAAOpH,EAAKS,OACZ6D,EAAMtE,EAAK,GAAGS,OACZ2F,EAAQpG,EAAKsC,QAEXH,EAAE,EAAEA,EAAEiF,EAAOjF,GAAI,EACtB,IAAI,IAAIC,EAAE,EAAEA,EAAEkC,EAAMlC,GAAI,EACxB,CAEK,IAAM9B,EAAK8F,EAAQjE,GAAGC,GAChBiF,EAAG,2BACF/G,GADC,IAEJzB,OAAOmB,EAAKmC,GAAGC,KAAKnC,GAAWD,EAAKmC,GAAGC,KAAKlC,IAEhDkG,EAAQjE,GAAGC,GAAGiF,EAGb,IAAIC,EAAKzF,KAAKY,SAEf,GAAIN,EAAE,GAAG,GAAGmF,EAAK,IAAOnF,EAAE,GAAG,GAAGC,EAAE,EAAE,EAClC,CACG,IAAMmF,EAAMnB,EAAQjE,EAAE,GAAGC,GAEnBoF,EAAG,2BACFD,GADC,IAEJ1I,OAAOmB,EAAKmC,EAAE,GAAGC,KAAKnC,GAAWD,EAAKmC,EAAE,GAAGC,KAAKlC,IAEpDkG,EAAQjE,EAAE,GAAGC,GAAGoF,EAGpB,GAAIpF,EAAE,GAAG,GAAGkF,GAAM,IAAMnF,EAAE,EAAE,GAAGC,EAAE,GAAG,EAChC,CACI,IAAMqF,EAAMrB,EAAQjE,GAAGC,EAAE,GAEnBsF,EAAG,2BACFD,GADC,IAEJ5I,OAAOmB,EAAKmC,GAAGC,EAAE,KAAKnC,GAAWD,EAAKmC,GAAGC,EAAE,KAAKlC,IAEpDkG,EAAQjE,GAAGC,EAAE,GAAGsF,GAUjC,OAAOtB,EDuKgBuB,CAAetF,EAAKA,EAAKyC,GAAgBC,GAAgB1C,EAAK2C,GAAiBC,IAC7FzG,KAAK2H,SAAS,CAACnG,KAAKoG,EAAQX,SAAS,mBACrC,MAEF,IAAK,UAAW,IAAMW,EAAQlE,EAAQG,EAAKA,EAAKyC,GAAgBC,GAAgB1C,EAAK2C,GAAiBC,IACpGzG,KAAK2H,SAAS,CAACnG,KAAKoG,EAAQX,SAAS,YACrC,MAED,IAAK,oBACH,IAAMW,EAAQ9C,EAAiBjB,EAAK,KAAKA,EAAKyC,GAAgBC,GAAgB1C,EAAK2C,GAAiBC,IACrGzG,KAAK2H,SAAS,CAACnG,KAAKoG,EAAQX,SAAS,sBACrC,MACA,IAAK,gCACH,IAAMW,EAAQ9C,EAAiBjB,EAAK,WAAWA,EAAKyC,GAAgBC,GAAgB1C,EAAK2C,GAAiBC,IAC3GzG,KAAK2H,SAAS,CAACnG,KAAKoG,EAAQX,SAAS,sBACrC,MACA,IAAK,kCACJ,IAAMW,EAAQ9C,EAAiBjB,EAAK,aAAaA,EAAKyC,GAAgBC,GAAgB1C,EAAK2C,GAAiBC,IAC7GzG,KAAK2H,SAAS,CAACnG,KAAKoG,EAAQX,SAAS,yB,sCAYhCtF,EAAqB4B,GAA2B,IAAD,OACzD,GAAI5B,GAAkD,IAA7BA,EAAoBM,OAYjD,IAb6D,eAapD0B,GACP,GAAIA,IAAMhC,EAAoBM,QAAQsB,EAAyBtB,QAAQ,EAerE,OAdAmH,YAAW,WACT,EAAKC,oBAAoB9F,KACxB,GAAKI,GAEJ2F,EAAG,IAAIhB,KACPiB,EAAGD,EAAGf,UACNiB,EAAoC,IAAlCjG,EAAyBtB,OAAW,iBAAiBsB,EAAyBtB,OAEhFwH,EAAG,aADCF,EAAG5C,GACY,YAAY6C,EACnC,EAAK7B,SAAS,CAACvF,IAAIqH,IAKb,CAAN,UAIFL,YAAW,WAGT,IAAMtH,EAAOH,EAAoBgC,GAC7B7B,IAEJ4H,SAASC,eAAT,eAAgC7H,EAAKrB,IAArC,YAA4CqB,EAAK5B,MAAOmB,UACtD,uBAID,GAAKsC,GAGJ2F,EAAG,IAAIhB,KACPiB,EAAGD,EAAGf,UACNiB,EAAqC,IAAlCjG,EAAyBtB,OAAY,iBAAiBsB,EAAyBtB,OAElFwH,EAAG,aADCF,EAAG5C,GACY,YAAY6C,EACnC,EAAK7B,SAAS,CAACvF,IAAIqH,KAvCZ9F,EAAI,EAAKhC,GAAqBgC,GAAKhC,EAAoBM,OAAQ0B,IAAK,CAAC,IAoCxE6F,EApCuE,IAApE7F,GAAoE,sCAZzE,CAEI,IAAI2F,EACJC,GADID,EAAG,IAAIhB,MACLC,UAGNkB,EAAG,aADCF,EAAG5C,GACY,oBACvB3G,KAAK2H,SAAS,CAACvF,IAAIqH,O,0CAqDLlG,GAClB,IAD6C,IAAD,WACnCI,GACPyF,YAAW,WACT,IAAMtH,EAAOyB,EAAyBI,GACtC+F,SAASC,eAAT,eAAgC7H,EAAKrB,IAArC,YAA4CqB,EAAK5B,MAAOmB,UACtD,4BAED,GAAKsC,IANDA,EAAI,EAAGA,EAAIJ,EAAyBtB,OAAQ0B,IAAM,EAAlDA,K,kCAcT,IAJU,IAEHnC,EAAMxB,KAAK6G,MAAXrF,KAECmC,GADAiG,KAAKC,MAAMD,KAAKE,UAAUtI,IACxB,GAAEmC,EAAEnC,EAAKS,OAAO0B,IAC1B,IAAI,IAAIC,EAAE,EAAEA,EAAEpC,EAAK,GAAGS,OAAO2B,IAE3B8F,SAASC,eAAT,eAAgChG,EAAhC,YAAqCC,IAAKmG,UAAUC,OAAO,gBAC3DN,SAASC,eAAT,eAAgChG,EAAhC,YAAqCC,IAAKmG,UAAUC,OAAO,sBAuB7DN,SAASC,eAAT,eAAgCrD,EAAhC,YAAkDC,IAAkBlF,UAAU,kBAC5EqI,SAASC,eAAT,eAAgCnD,EAAhC,YAAmDC,IAAmBpF,UAAU,mBAYjF,IAFA,IAAMwC,EAAM,GAEHpD,EAAM,EAAGA,GAAM,GAAIA,IAAO,CAEjC,IADA,IAAMwJ,EAAa,GACV/J,EAAM,EAAGA,GAAM,GAAIA,IAAO,CAElC,IAAMgK,EAAGC,EAAWjK,EAAKO,GAEzBwJ,EAAWlI,KAAKmI,GAEjBrG,EAAK9B,KAAKkI,GAIZ,IAAI,IAAItG,EAAE,EAAEA,EAAEE,EAAK5B,OAAO0B,IAC1B,IAAI,IAAIC,EAAE,EAAEA,EAAEC,EAAK,GAAG5B,OAAO2B,IAGxBpC,EAAKmC,GAAGC,GAAGvD,SACVwD,EAAKF,GAAGC,GAAGvD,QAAO,GAKxBL,KAAK2H,SAAS,CAACnG,KAAKqC,M,kCASpB,IAJS,IAEHrC,EAAQxB,KAAK6G,MAAbrF,KACAZ,EAAEgJ,KAAKC,MAAMD,KAAKE,UAAUtI,IAAOsC,QACjCH,EAAE,EAAEA,EAAE0C,EAAQpE,OAAO0B,IACzB,CAAC,IAAM7B,EAAKuE,EAAQ1C,GAEjB+F,SAASC,eAAT,eAAgC7H,EAAKrB,IAArC,YAA4CqB,EAAK5B,MAAO6J,UAAUC,OAAO,gBAG7E,IAAI,IAAIrG,EAAE,EAAEA,EAAE+C,EAAKzE,OAAO0B,IACzB,CACC,IAAM7B,EAAK4E,EAAK/C,GAEhB+F,SAASC,eAAT,eAAgC7H,EAAKrB,IAArC,YAA4CqB,EAAK5B,MAAO6J,UAAUC,OAAO,sBAOhFN,SAASC,eAAT,eAAgCrD,EAAhC,YAAkDC,IAAkBlF,UAAU,kBAC1EqI,SAASC,eAAT,eAAgCnD,EAAhC,YAAmDC,IAAmBpF,UAAU,mBAE9ET,EAAE0F,GAAgBC,GAAgBnG,SAAQ,EAC1CQ,EAAE4F,GAAiBC,GAAiBtG,UAAS,EAK7C,IAFA,IAAM0D,EAAM,GAEHpD,EAAM,EAAGA,GAAM,GAAIA,IAAO,CAEjC,IADA,IAAMwJ,EAAa,GACV/J,EAAM,EAAGA,GAAM,GAAIA,IAAO,CACjC,IAAMgK,EAAGC,EAAWjK,EAAKO,GAE1BwJ,EAAWlI,KAAKmI,GAEjBrG,EAAK9B,KAAKkI,GAEHvC,IAGV1H,KAAK2H,SAAS,CAACnG,KAAKqC,EAAKoD,SAAS,aAAaC,KAAK,GAAGC,SAAS,GAAG/E,IAF5D,4C,0CAOQ,IACZZ,EAAQxB,KAAK6G,MAAbrF,KAEDC,EAAYD,EAAK8E,GAAgBC,GACjC7E,EAAaF,EAAKgF,GAAiBC,GAEnC9E,EAAsBJ,EAASC,EAAMC,EAAWC,GACjD2E,EAAQ1E,EAAoBmC,QAEhC,IAAMP,EP7WJ,SAAqC7B,GAC1C,IAAM6B,EAA2B,GAC7B6G,EAAc1I,EAClB,IAAIA,EAAWT,aACX,OAAOsC,EACX,KAAuB,OAAhB6G,GACL7G,EAAyB8G,QAAQD,GACjCA,EAAcA,EAAYnJ,aAE5B,OAAOsC,EOoW6B+G,CAA4B5I,GACvDgF,EAAKnD,EAC8B,IAAlCA,EAAyBtB,QACxBsB,EAAyBjB,QAElCtC,KAAKuK,gBAAgB5I,EAAqB4B,K,uCAI1B,IACT/B,EAAQxB,KAAK6G,MAAbrF,KAEDC,EAAYD,EAAK8E,GAAgBC,GACjC7E,EAAaF,EAAKgF,GAAiBC,GAEnC9E,EAAsBsB,EAAMzB,EAAMC,EAAWC,GAC9C2E,EAAQ1E,EAAoBmC,QAC5B3B,QAAQC,IAAIT,EAAoBM,QAEpC,IAAMsB,EN1XF,SAA0C7B,GAC/C,IAAM6B,EAA2B,GAC/B,IAAI7B,EAAWT,aACb,OAAOsC,EAEX,IADA,IAAI6G,EAAc1I,EACK,OAAhB0I,GACL7G,EAAyB8G,QAAQD,GACjCA,EAAcA,EAAYnJ,aAE5B,OAAOsC,EMiX2BiH,CAAiC9I,GAC5DgF,EAAKnD,EAGZvD,KAAKuK,gBAAgB5I,EAAqB4B,K,qCAG5B,IACP/B,EAAQxB,KAAK6G,MAAbrF,KAEDC,EAAYD,EAAK8E,GAAgBC,GACjC7E,EAAaF,EAAKgF,GAAiBC,GAEnC9E,ELzdH,SAAaH,EAAKC,EAAUC,GAC/B,IAAMC,EAAoB,GAErB8I,EAAE,GASR,IAPAA,EAAE1I,KAAKN,GAEPA,EAAUV,WAAU,EAEpBY,EAAoBI,KAAKN,GAGR,IAAXgJ,EAAExI,QACR,CACI,IAAIyI,EAAMD,EAAEnI,QAEZ,GAAGoI,IAAQhJ,EAEP,OAAOC,EAMR,IAHH,IAAMgJ,EAAmB3H,EAAsB0H,EAAMlJ,GAG1CmC,EAAE,EAAEA,EAAEgH,EAAmB1I,OAAO0B,IACxC,CAAG,IAAMZ,EAAS4H,EAAmBhH,GACjCZ,EAAShC,WAAU,EACnBgC,EAAS9B,aAAayJ,EACtB/I,EAAoBI,KAAKgB,GACzB0H,EAAE1I,KAAKgB,IAMlB,OAAOpB,EKsbsBiJ,CAAIpJ,EAAMC,EAAWC,GAC5C2E,EAAQ1E,EAAoBmC,QAEhC,IAAMP,EL7aF,SAAwC7B,GAC7C,IAAM6B,EAA2B,GAC7B6G,EAAc1I,EAClB,IAAIA,EAAWT,aACb,OAAOsC,EACT,KAAuB,OAAhB6G,GACL7G,EAAyB8G,QAAQD,GACjCA,EAAcA,EAAYnJ,aAE5B,OAAOsC,EKoa2BsH,CAA+BnJ,GAC1DgF,EAAKnD,EAGZvD,KAAKuK,gBAAgB5I,EAAqB4B,K,qCAG5B,IACP/B,EAAQxB,KAAK6G,MAAbrF,KAEDC,EAAYD,EAAK8E,GAAgBC,GACjC7E,EAAaF,EAAKgF,GAAiBC,GAEnC9E,EJ5eH,SAAaH,EAAKC,EAAUC,GAC/B,IAAMC,EAAoB,GACrBmJ,GAAQ,EACRL,EAAE,GAIR,IAHAA,EAAE1I,KAAKN,GACPA,EAAUV,WAAU,EACpBY,EAAoBI,KAAKN,GACR,IAAXgJ,EAAExI,QACR,CACI,IAAIyI,EAAMD,EAAEM,MACZ,GAAGL,IAAQhJ,EAEP,OADCoJ,GAAQ,EACFnJ,EAEX,GAAGmJ,EACF,MAGE,IADH,IAAMH,EAAmB3H,EAAsB0H,EAAMlJ,GAC1CmC,EAAE,EAAEA,EAAEgH,EAAmB1I,OAAO0B,IACxC,CAAG,IAAMZ,EAAS4H,EAAmBhH,GACjCZ,EAAShC,WAAU,EACnBgC,EAAS9B,aAAayJ,EACtB/I,EAAoBI,KAAKgB,GACzB0H,EAAE1I,KAAKgB,IAMlB,OAAOpB,EI+csBqJ,CAAIxJ,EAAMC,EAAWC,GAC5C2E,EAAQ1E,EAAoBmC,QAEhC,IAAMP,EJpcF,SAAwC7B,GAC7C,IAAM6B,EAA2B,GAC7B6G,EAAc1I,EAClB,IAAIA,EAAWT,aACb,OAAOsC,EACT,KAAuB,OAAhB6G,GACL7G,EAAyB8G,QAAQD,GACjCA,EAAcA,EAAYnJ,aAE5B,OAAOsC,EI2b2B0H,CAA+BvJ,GAC1DgF,EAAKnD,EAGZvD,KAAKuK,gBAAgB5I,EAAqB4B,K,sCAG3B,IACR/B,EAAQxB,KAAK6G,MAAbrF,KAEDC,EAAYD,EAAK8E,GAAgBC,GACjC7E,EAAaF,EAAKgF,GAAiBC,GAEnC9E,EHzfH,SAAuBH,EAAKC,EAAUC,GACzC,IAAMC,EAAoB,GACzB4B,EAAyB,GAC3B,IAAM2H,EAAG,GACHC,EAAG,GAeT,IAbAD,EAAGnJ,KAAKN,GACR0J,EAAGpJ,KAAKL,GAERD,EAAUV,WAAU,EACpBU,EAAUT,cAAa,EACvBU,EAAWX,WAAU,EACrBW,EAAWV,cAAa,EAGxBW,EAAoBI,KAAKN,GACzBE,EAAoBI,KAAKL,GAGP,IAAZwJ,EAAGjJ,QAAwB,IAAZkJ,EAAGlJ,QACxB,CACI,IAAImJ,EAAOF,EAAG5I,QACV+I,EAAOF,EAAG7I,QACd,GAAY,OAAT8I,GAAwB,OAATC,EAEf,OADClJ,QAAQC,IAAI,aACNT,EAER,GAAKyJ,EACP,CAEC,GAAKA,GAAQA,EAAOpK,aACrB,CAGC,IAFA,IAAIsK,EAAeF,EACfG,EAAeH,EACK,OAAjBE,GACL/H,EAAyB8G,QAAQiB,GACjCA,EAAeA,EAAapK,kBAC9B,KAAwB,OAAjBqK,GACJhI,EAAyB8G,QAAQkB,GAChCA,EAAeA,EAAapK,gBAG7B,OADDgB,QAAQC,IAAI,cACJT,EAEX,IAAM6J,EAAwBhI,EAA2B4H,EAAO5J,GAC7DW,QAAQC,IAAIoJ,EAAwBvJ,OAAO,eAE3C,IAAI,IAAI0B,EAAE,EAAI6H,GAAyB7H,EAAE6H,EAAwBvJ,OAAO0B,IACxE,CAAG,IAAM8H,EAAUD,EAAwB7H,GAGvC8H,EAAU1K,WAAU,EAEpB0K,EAAUvK,kBAAkBkK,EAE5BzJ,EAAoBI,KAAK0J,GAEzBP,EAAGnJ,KAAK0J,IAMZ,GAAKJ,EACP,CAEE,GAAKA,GAAQA,EAAOtK,UACtB,CAGC,IAFA,IAAIuK,EAAeD,EACfE,EAAeF,EACK,OAAjBC,GACL/H,EAAyB8G,QAAQiB,GACjCA,EAAeA,EAAanK,gBAE9B,KAAwB,OAAjBoK,GACHhI,EAAyB8G,QAAQkB,GACjCA,EAAeA,EAAarK,kBAGhC,OADAiB,QAAQC,IAAI,cACLT,EAGT,IAAM+J,EAAsBjI,EAAyB4H,EAAO7J,GAC5DW,QAAQC,IAAIsJ,EAAsBzJ,OAAO,cACtC,IAAI,IAAI2B,EAAE,EAAI8H,GAAuB9H,EAAE8H,EAAsBzJ,OAAO2B,IACpE,CACE,IAAM+H,EAAUD,EAAsB9H,GAGpC+H,EAAU3K,cAAa,EAEvB2K,EAAUxK,gBAAgBkK,EAE1B1J,EAAoBI,KAAK4J,GAEzBR,EAAGpJ,KAAK4J,KAMnB,OAAOhK,EGoZsBiK,CAAcpK,EAAMC,EAAWC,GACjDC,GACAQ,QAAQC,IAAI,uBACjBiE,EAAQ1E,EAAoBmC,QAEhC,IAAMP,EH3XAA,EG4XAmD,EAAKnD,EAGZvD,KAAKuK,gBAAgB5I,EAAqB4B,K,+BAIlC,IAAD,SACwBvD,KAAK6G,MAA7BrF,EADA,EACAA,KAAMsF,EADN,EACMA,eAEb,OACE,yBAAKzF,UAAU,WACZ,4BACE,wBAAIA,UAAU,SAAd,iBACE,4BACJ,4BAAI,4BAAQA,UAAU,WAAWwK,QAAS,kBAAI,EAAKzE,cAA/C,eAEH,4BACE,yBAAK/F,UAAU,kBACf,4BAAQA,UAAU,aAAc+G,MAAOpI,KAAK6G,MAAMK,KAAO4E,SAAU,SAAC7D,GAAS,EAAKT,iBAAiBS,KAEpG,4BAAQG,MAAM,IAAd,cACA,4BAAQA,MAAM,wBAAd,wBACA,4BAAQA,MAAM,aAAd,aACA,4BAAQA,MAAM,wBAAd,wBACA,4BAAQA,MAAM,sBAAd,sBACA,4BAAQA,MAAM,wBAAd,4BAOJ,4BAAI,4BAAS/G,UAAU,eAAewK,QAAS,kBAAM,EAAKE,kBAAtD,oBACa/L,KAAK6G,MAAMK,KADxB,gBAGH,4BAAI,4BAAQ7F,UAAU,YAAYwK,QAAS,kBAAI,EAAKpE,cAAhD,eACJ,wBAAIpG,UAAU,YAAd,WAA8BrB,KAAK6G,MAAMM,SAAzC,MACE,wBAAI9F,UAAU,aAAd,KAAgC,wBAAIA,UAAU,SAAd,UAChC,wBAAIA,UAAU,cAAd,KAAiC,wBAAIA,UAAU,UAAd,WACjC,wBAAIA,UAAU,eAAd,KAAkC,wBAAIA,UAAU,WAAd,YAClC,wBAAIA,UAAU,YAAd,KAA+B,wBAAIA,UAAU,QAAd,kBAC/B,wBAAIA,UAAU,YAAd,KAA+B,wBAAIA,UAAU,QAAd,SAC/B,wBAAIA,UAAU,UAAd,KACA,wBAAIA,UAAU,OAAd,WAAyBrB,KAAK6G,MAAMzE,IAApC,MAEA,6BACD,gCAAK,4BAAQf,UAAU,aAAa+G,MAAOpI,KAAK6G,MAAMI,SAAU6E,SAAU,SAAC7D,GAAD,OAAS,EAAKV,iBAAiBU,KACxG,4BAAQG,MAAM,cAAd,SACA,4BAAQA,MAAM,kBAAd,kBACA,4BAAQA,MAAM,WAAd,WACA,4BAAQA,MAAM,qBAAd,sBACA,4BAAQA,MAAM,iCAAd,qCACA,4BAAQA,MAAM,mCAAd,4CAOF,yBAAK/G,UAAU,QACZG,EAAKwK,KAAI,SAACvL,EAAKwL,GACd,OACE,yBAAKC,IAAKD,EAAQ5K,UAAU,cACzBZ,EAAIuL,KAAI,SAAClK,EAAMqK,GAAa,IACpB1L,EACoBqB,EADpBrB,IAAKP,EACe4B,EADf5B,IAAKC,EACU2B,EADV3B,SAAUC,EACA0B,EADA1B,QAASC,EACTyB,EADSzB,OAAOU,EAChBe,EADgBf,UAAUC,EAC1Bc,EAD0Bd,aAAaC,EACvCa,EADuCb,aAAaC,EACpDY,EADoDZ,kBAC9EC,EAA0BW,EAA1BX,gBAAgBR,EAAUmB,EAAVnB,EAAEC,EAAQkB,EAARlB,EAAEC,EAAMiB,EAANjB,EACrB,OACE,kBAAC,EAAD,CACEqL,IAAKC,EACLjM,IAAKA,EACLC,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACRU,UAAWA,EACXC,aAAcA,EACdC,aAAcA,EACdC,kBAAmBA,EACnBC,gBAAiBA,EACjBR,EAAGA,EACHC,EAAGA,EACHC,EAAGA,EACHiG,eAAgBA,EAChBxG,YAAa,SAACG,EAAKP,GAAN,OAAc,EAAKkM,gBAAgB3L,EAAKP,IACrDK,aAAc,SAACE,EAAKP,GAAN,OAAa,EAAKmM,iBAAiB5L,EAAKP,IACtDM,UAAW,SAACC,EAAIP,GAAL,OAAa,EAAKoM,cAAc7L,EAAIP,IAC/CO,IAAKA,iB,GAhkBwBa,aA8kB7CoG,EAAiB,WAGrB,IAFA,IAAMlG,EAAO,GAEJf,EAAM,EAAGA,GAAM,GAAIA,IAAO,CAEjC,IADA,IAAMwJ,EAAa,GACV/J,EAAM,EAAGA,GAAM,GAAIA,IAC1B+J,EAAWlI,KAAKoI,EAAWjK,EAAKO,IAElCe,EAAKO,KAAKkI,GAEZ,OAAOzI,GAGH2I,EAAa,SAACjK,EAAKO,GACvB,MAAO,CACLP,MACAO,MACAL,QAASK,IAAQ6F,GAAkBpG,IAAQqG,EAC3CpG,SAAUM,IAAQ+F,GAAmBtG,IAAQuG,EAC7C3F,SAAUyB,IACVxB,WAAW,EACXC,cAAc,EACdX,QAAQ,EACRY,aAAc,KACdC,kBAAmB,KACnBC,gBAAiB,KACjBR,EAAE4B,IACF3B,EAAE,EACFC,EAAE0B,MAQAuF,EAA4B,SAACtG,EAAMf,EAAKP,GAC5C,IAAM0H,EAAUpG,EAAKsC,QACfhC,EAAO8F,EAAQnH,GAAKP,GAIpB2H,EAAO,2BACR/F,GADQ,IAEXzB,QAASyB,EAAKzB,SAIhB,OADAuH,EAAQnH,GAAKP,GAAO2H,EACbD,GAGHG,EAAwB,SAACvG,EAAMf,EAAKP,GAExCoG,EAAe7F,EACf8F,EAAerG,EACf,IAAM0H,EAAUpG,EAAKsC,QACfhC,EAAO8F,EAAQnH,GAAKP,GACpB2H,EAAO,2BACR/F,GADQ,IAEXzB,QAAO,EACPD,QAASK,IAAQ6F,GAAkBpG,IAAQqG,IAK7C,OADAqB,EAAQnH,GAAKP,GAAO2H,EACbD,GAGHI,EAAsB,SAACxG,EAAMf,EAAKP,GAEtCsG,EAAgB/F,EAChBgG,EAAgBvG,EAChB,IAAM0H,EAAUpG,EAAKsC,QACfhC,EAAO8F,EAAQnH,GAAKP,GACpB2H,EAAO,2BACR/F,GADQ,IAEXzB,QAAO,EACPF,SAAUM,IAAQ+F,GAAmBtG,IAAQuG,IAG/C,OADAmB,EAAQnH,GAAKP,GAAO2H,EACbD,GEzqBM2E,MARf,WACE,OACE,yBAAKlL,UAAU,OACb,kBAAC,EAAD,QCIcmL,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFrD,SAASC,eAAe,SDyHpB,kBAAmBqD,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLpL,QAAQoL,MAAMA,EAAMC,c","file":"static/js/main.7121947a.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      f,\n      g,\n      h,\n      distance,\n      isVisited,\n      otherVisited,\n      previousNode,\n      previousNodeStart,\n      previousNodeEnd,\n     \n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : ''\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp(row,col)}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes&&unvisitedNodes.length>0) {\n    sortNodesByDistance(unvisitedNodes);\n    \n    console.log(unvisitedNodes.length+\" unLen\")\n    const closestNode = unvisitedNodes.shift();\n\n    console.log(closestNode.distance+\" cloD \"+closestNode.isVisited+\" \"+closestNode.isWall)\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall||closestNode.isVisited)\n     continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) \n      {   console.log(\"return from here\")\n        return visitedNodesInOrder;}\n    closestNode.isVisited = true;\n\n    console.log(\"pushed\")\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) \n        return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n\n  console.log(\"Vis Len \"+visitedNodesInOrder.length)\n   return visitedNodesInOrder;\n  \n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  console.log(\"sorting\")\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if(!neighbor.isWall&&neighbor.distance>(node.distance+1))  \n   { neighbor.distance = node.distance + 1;\n    console.log(\"dist updated\")\n       neighbor.previousNode = node;}\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  \n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  /*if(row>0&&col>0)neighbors.push(grid[row - 1][col-1]);\n  if(row>0&&col < grid[0].length - 1)neighbors.push(grid[row - 1][col+1]);\n  if((row < grid.length - 1)&&col < grid[0].length - 1)neighbors.push(grid[row+1][col+1]);\n  if((row < grid.length - 1)&&col>0)neighbors.push(grid[row+1][col-1]);*/\n  return neighbors.filter(neighbor => !neighbor.isVisited&&!neighbor.isWall);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  if(!finishNode.previousNode)\n      return nodesInShortestPathOrder\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function astar(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n     startNode.g=0\n     startNode.h=heuristic(startNode,finishNode)\n     startNode.f=startNode.g+startNode.h\n     console.log(\"in a star\")\n    const unvisitedNodes = getAllNodes(grid);\n    console.log(unvisitedNodes.length)\n    while (!!unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n         console.log(closestNode.f+\" \"+closestNode.g+\" \"+closestNode.h)\n      if (closestNode.f === Infinity) \n        {   console.log(visitedNodesInOrder.length)\n          return visitedNodesInOrder;}\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid,finishNode);\n    }\n    return visitedNodesInOrder\n  }\n  \n  function sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) =>{\n         if((nodeA.f===nodeB.f))\n        return nodeA.h - nodeB.h;\n        return nodeA.f-nodeB.f;\n        });\n  }\n  \n  function updateUnvisitedNeighbors(node, grid,finishNode) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      if(neighbor.f>=node.f+1)\n      {neighbor.g=node.g+1;\n      neighbor.h=heuristic(neighbor,finishNode)\n      neighbor.f=neighbor.g+neighbor.h;\n      neighbor.previousNode = node;\n     }\n    }\n  }\n  \n  function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    \n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    /*if(row>0&&col>0)neighbors.push(grid[row - 1][col-1]);\n    if(row>0&&col < grid[0].length - 1)neighbors.push(grid[row - 1][col+1]);\n    if((row < grid.length - 1)&&col < grid[0].length - 1)neighbors.push(grid[row+1][col+1]);\n    if((row < grid.length - 1)&&col>0)neighbors.push(grid[row+1][col-1]);*/\n    return neighbors.filter(neighbor => !neighbor.isVisited&&!neighbor.isWall);\n  }\n  \n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n\n\n  function heuristic(a,b)\n{\n    let d=Math.abs(a.row-b.row)+Math.abs(a.col-b.col)\n    return d;\n}\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrderAstar(finishNode) {\n    const nodesInShortestPathOrder = [];\n      if(!finishNode.previousNode)\n        return nodesInShortestPathOrder\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","\n\n\nexport function BFS(grid,startNode,finishNode){\n    const visitedNodesInOrder=[]\n   \n   const q=[];\n   \n   q.push(startNode);\n   \n   startNode.isVisited=true\n   \n   visitedNodesInOrder.push(startNode)\n   \n\n   while(q.length!==0)\n   {  \n       let qNode=q.shift();\n       \n       if(qNode===finishNode)\n       {   \n           return visitedNodesInOrder\n       }\n\n       const unVisitedNeighbors=getUnvisitedNeighbors(qNode,grid)\n       \n\n          for(let i=0;i<unVisitedNeighbors.length;i++)\n          {  const neighbor=unVisitedNeighbors[i]\n              neighbor.isVisited=true\n              neighbor.previousNode=qNode\n              visitedNodesInOrder.push(neighbor)\n              q.push(neighbor)\n\n          }\n\n\n   }\n   return visitedNodesInOrder\n}\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    \n    return neighbors.filter(neighbor => !neighbor.isVisited&&!neighbor.isWall);\n  }\n  export function getNodesInShortestPathOrderBFS(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    if(!finishNode.previousNode)\n      return nodesInShortestPathOrder\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function DFS(grid,startNode,finishNode){\n    const visitedNodesInOrder=[]\n     let Isfound=false \n   const q=[];\n   q.push(startNode);\n   startNode.isVisited=true\n   visitedNodesInOrder.push(startNode)\n   while(q.length!==0)\n   {  \n       let qNode=q.pop();\n       if(qNode===finishNode)\n       {    Isfound=true\n           return visitedNodesInOrder\n       }\n       if(Isfound)\n        break  \n\n       const unVisitedNeighbors=getUnvisitedNeighbors(qNode,grid)\n          for(let i=0;i<unVisitedNeighbors.length;i++)\n          {  const neighbor=unVisitedNeighbors[i]\n              neighbor.isVisited=true\n              neighbor.previousNode=qNode\n              visitedNodesInOrder.push(neighbor)\n              q.push(neighbor)\n\n          }\n\n\n   }\n   return visitedNodesInOrder\n\n}\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    \n    \n    return neighbors.filter(neighbor => !neighbor.isVisited&&!neighbor.isWall);\n  }\n  export function getNodesInShortestPathOrderDFS(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    if(!finishNode.previousNode)\n      return nodesInShortestPathOrder\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","\n\nlet nodesInShortestPathOrder = [];\nexport function biDirectional(grid,startNode,finishNode){\n    const visitedNodesInOrder=[]\n     nodesInShortestPathOrder=[]\n   const q1=[];\n   const q2=[];\n   \n   q1.push(startNode);\n   q2.push(finishNode);\n   \n   startNode.isVisited=true\n   startNode.otherVisited=false\n   finishNode.isVisited=false\n   finishNode.otherVisited=true\n\n   \n   visitedNodesInOrder.push(startNode)\n   visitedNodesInOrder.push(finishNode)\n   \n\n   while(q1.length!==0||q2.length!==0)\n   {  \n       let qNode1=q1.shift();\n       let qNode2=q2.shift();\n       if(qNode1===null&&qNode2===null)\n        {  console.log(\"both null\")\n          return visitedNodesInOrder}\n          \n         if(!!qNode1)\n       {\n         \n        if(!!qNode1&&qNode1.otherVisited)\n       {   \n        let currentNode1 = qNode1;\n        let currentNode2 = qNode1;\n        while (currentNode1 !== null) {\n          nodesInShortestPathOrder.unshift(currentNode1);\n          currentNode1 = currentNode1.previousNodeStart;}\n        while (currentNode2 !== null) {\n           nodesInShortestPathOrder.unshift(currentNode2);\n            currentNode2 = currentNode2.previousNodeEnd;\n        }\n          console.log(\"q1 is null\")\n           return visitedNodesInOrder}\n      \n       const unVisitedNeighborsStart=getUnvisitedNeighborsStart(qNode1,grid)\n          console.log(unVisitedNeighborsStart.length+\"  start len\")\n\n          for(let i=0;!!unVisitedNeighborsStart&&i<unVisitedNeighborsStart.length;i++)\n          {  const neighborS=unVisitedNeighborsStart[i]\n            \n\n              neighborS.isVisited=true\n             \n              neighborS.previousNodeStart=qNode1\n              \n              visitedNodesInOrder.push(neighborS)\n              \n              q1.push(neighborS)\n             \n\n          }\n       }\n      \n          if(!!qNode2)\n        {\n          \n          if(!!qNode2&&qNode2.isVisited)\n        {   \n         let currentNode1 = qNode2;\n         let currentNode2 = qNode2;\n         while (currentNode1 !== null) {\n           nodesInShortestPathOrder.unshift(currentNode1);\n           currentNode1 = currentNode1.previousNodeEnd;\n         }\n         while (currentNode2 !== null) {\n             nodesInShortestPathOrder.unshift(currentNode2);\n             currentNode2 = currentNode2.previousNodeStart;\n         }\n         console.log(\"q2 is null\")\n         return visitedNodesInOrder}\n        \n\n       const unVisitedNeighborsEnd=getUnvisitedNeighborsEnd(qNode2,grid)\n       console.log(unVisitedNeighborsEnd.length+\"   endNlen\")\n          for(let j=0;!!unVisitedNeighborsEnd&&j<unVisitedNeighborsEnd.length;j++)\n          {  \n            const neighborE=unVisitedNeighborsEnd[j]\n\n             \n              neighborE.otherVisited=true\n              \n              neighborE.previousNodeEnd=qNode2\n              \n              visitedNodesInOrder.push(neighborE)\n              \n              q2.push(neighborE)\n\n          }\n       \n        }\n   }\n   return visitedNodesInOrder\n     \n\n}\nfunction getUnvisitedNeighborsStart(node, grid) {\n     //if(!node)\n       //return \n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    \n    return neighbors.filter(neighbor => !neighbor.isVisited&&!neighbor.isWall);\n  }\n  function getUnvisitedNeighborsEnd(node, grid) {\n    // if(!node)\n     // return\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    \n    return neighbors.filter(neighbor => !neighbor.otherVisited&&!neighbor.isWall);\n  }\n  export function getNodesInShortestPathOrderBiDi(finishNode) {\n   \n    return nodesInShortestPathOrder;\n  }\n  ","export function dfsMaze(grid,startNode,finishNode){\n    \n  //const newGrid=grid.slice();\n  for(let i=0;i<grid.length;i++)\n  {  for(let j=0;j<grid[0].length;j++)\n     {\n         \n      grid[i][j].isWall=(grid[i][j]!==startNode&&grid[i][j]!==finishNode)?true:false\n           \n           \n\n     }\n     \n  }\n  \n  \n  \n  const visitedNodesInOrder=[]\n  const Grid=grid.slice()\n     \n   let randRow=Math.floor(Math.random()*(grid.length-1))\n   let randCol=Math.floor(Math.random()*(grid[0].length-1))\n     console.log(Grid)\n    if(!(!!Grid))\n       console.log(null)\n    if(!!Grid)\n      { Grid[randRow][randCol].isWall=false}\n      \n    recursion(Grid,randRow,randCol);\n    return Grid;\n\n}\n\n\n  \n   \n       \n     \n    \n  function recursion(grid,r,c) {\n    // 4 random directions\n    const randDirs = generateRandomDirections();\n    // Examine each direction\n    for (let i = 0; i < randDirs.length; i++) {\n\n        switch(randDirs[i]){\n        case 1: // Up\n            //　Whether 2 cells up is out or not\n            if (r - 2 <= 0)\n                continue;\n                \n            if (grid[r - 2][c].isWall) {\n                grid[r-2][c].isWall=false\n                grid[r-1][c].isWall=false\n                recursion(grid,r - 2, c);\n            }\n            break;\n        case 2: // Right\n            // Whether 2 cells to the right is out or not\n            if (c + 2 >= grid[0].length - 1)\n                continue;\n                \n            if (grid[r][c + 2].isWall) {\n                grid[r][c + 2].isWall=false\n                grid[r][c + 1].isWall=false\n                recursion(grid,r, c + 2);\n            }\n            break;\n        case 3: // Down\n            // Whether 2 cells down is out or not\n            if (r + 2 >= grid.length - 1)\n                continue;\n                \n            if (grid[r + 2][c].isWall) {\n                grid[r+2][c].isWall=false\n                grid[r+1][c].isWall=false\n                recursion(grid,r + 2, c);\n            }\n            break;\n        case 4: // Left\n            // Whether 2 cells to the left is out or not\n            if (c - 2 <= 0)\n                continue;\n                \n            if (grid[r][c - 2].isWall) {\n                grid[r][c - 2].isWall=false\n                grid[r][c - 1].isWall=false\n                recursion(grid,r, c - 2);\n            }\n            break;\n        }\n    }\n\n  }\n\n\n  \n\n  function shuffle(arra1) {\n    let ctr = arra1.length;\n    let temp;\n    let index;\n\n    // While there are elements in the array\n    while (ctr > 0) {\n// Pick a random index\n        index = Math.floor(Math.random() * ctr);\n// Decrease ctr by 1\n        ctr--;\n// And swap the last element with it\n        temp = arra1[ctr];\n        arra1[ctr] = arra1[index];\n        arra1[index] = temp;\n    }\n    return arra1;\n}\n\nfunction generateRandomDirections() {\n  const dir=[]\n  for (let i = 0; i < 4; i++)\n       dir.push(i + 1);\n   \n  \n return shuffle(dir)\n  \n}"," let grid=[]\nexport function recursiveDivMaze(Grid,bias,start,finish){\n\t \n\n      grid=Grid.slice()\n\t   \n\tfor (var i = 0; i < grid.length; i++){\n\t\tfor (var j = 0; j < grid[0].length; j++){\n\t\t\tif (i == 0 || j == 0 || i == (grid.length - 1) || j == (grid[0].length - 1)){ \n\t\t\t\tgrid[i][j].isWall=true\n\t\t\t}\n\t\t}\n\t}\n\n\tvar walls = createVisited(grid);\n\tvar passages = createVisited(grid);\n\trecursiveDivMazeHelper(1, (grid.length - 2), 1, (grid[0].length - 2), 2, (grid.length - 3), 2, (grid[0].length - 3), walls, passages, bias,start,finish);\n\t \n\t grid[start.row][start.col].isWall=false;\n\t grid[finish.row][finish.col].isWall=false;\n\t \n\treturn grid\n\t\n}\n\n\n\nfunction recursiveDivMazeHelper(iStart, iEnd, jStart, jEnd, horzStart, horzEnd, vertStart, vertEnd, walls, passages, bias,start,finish){\n\tvar height = iEnd - iStart + 1;\n\tvar width = jEnd - jStart + 1;\n\tvar canMakeVertWall = (vertEnd - vertStart) >= 0;\n\tvar canMakeHorzWall = (horzEnd - horzStart) >= 0;\n \tif (height < 3 || width < 3 || !canMakeVertWall | !canMakeHorzWall) { \n\t\treturn; \n\t}\n\t// Choose line orientation\n\tvar x = Math.floor(Math.random() * 10);\n\tif (bias == \"VERTICAL\"){\n\t\tvar lineOrientation = x < 8 ? \"VERTICAL\" : \"HORIZONTAL\"; // weighting: 90/10 (V/H)\n\t} else if (bias == \"HORIZONTAL\"){\n\t\tvar lineOrientation = x < 1 ? \"VERTICAL\" : \"HORIZONTAL\"; // weighting: 10/90 (V/H)\n\t} else { \n\t\tvar lineOrientation = x < 5 ? \"VERTICAL\" : \"HORIZONTAL\"; // weighting: 50/50 (V/H)\n\t}\n\n\t// Draw line and create random passage\n\tif (lineOrientation == \"VERTICAL\"){\n\t\tvar vertWidth = vertEnd - vertStart + 1;\n\t\tvar randCol = Math.floor(Math.random() * vertWidth) + vertStart;\n\t\tif (passages[iStart][randCol]){\n\t\t\tvar randRow = iStart;\n\t\t} else if (passages[iEnd][randCol]){\n\t\t\tvar randRow = iEnd;\n\t\t} else {\n\t\t\tvar randRow = (Math.floor(Math.random() * 2) == 0) ? iStart: iEnd; // random end assignment\n\t\t\t//var randRow = Math.floor(Math.random() * height) + iStart; // random parition\n\t\t}\n\t\tfor (var i = iStart; i <= iEnd; i++){\n\t\t\tif ( passages[i][randCol] ){ continue; }\n\t\t\tif (i == randRow){\n\t\t\t\t// Make passages\n\t\t\t\tfor (var j = randCol - 1; j <= randCol + 1; j++){\n\t\t\t\t\tpassages[i][j] = true;\n\t\t\t\t}\n\t\t\t} else { \n\n\t\t\t\tif(!grid)\n\t\t\t\t   console.log(\"null \"+i+\" \"+randCol)\n\t\t\t\t//walls[i][randCol] = true;\n\t\t\t\tif( grid[i][randCol]!==start|| grid[i][randCol]!==finish)\n\t\t\t\t grid[i][randCol].isWall=true\n\t\t\t}\n\t\t}\n\t\trecursiveDivMazeHelper(iStart, iEnd, jStart, (randCol - 1), horzStart, horzEnd, vertStart, (randCol - 2), walls, passages,start,finish); //left\n\t\trecursiveDivMazeHelper(iStart, iEnd, (randCol + 1), jEnd, horzStart, horzEnd, (randCol + 2), vertEnd, walls, passages,start,finish); //right\n    }\n    \n    else {\n\t\tvar horzHeight = horzEnd - horzStart + 1;\n\t\tvar randRow = Math.floor(Math.random() * horzHeight) + horzStart;\n\t\tif (passages[randRow][jStart]){\n\t\t\tvar randCol = jStart;\n\t\t} else if (passages[randRow][jEnd]){\n\t\t\tvar randCol = jEnd;\n\t\t} else {\n\t\t\tvar randCol = (Math.floor(Math.random() * 2) == 0) ? jStart: jEnd; // random end assignment\n\t\t\t//var randCol = Math.floor(Math.random() * width) + jStart; // random parition\n\t\t}\n\t\tfor (var j = jStart; j <= jEnd; j++){\n\t\t\tif ( passages[randRow][j] ){ continue; }\n\t\t\tif (j == randCol){\n\t\t\t\t// Make passages\n\t\t\t\tfor (var i = randRow - 1; i <= randRow + 1; i++){\n\t\t\t\t\tpassages[i][j] = true;\n\t\t\t\t}\n\t\t\t} else { \n\n\t\t\t\t   if(!grid)\n\t\t\t\t   console.log(\"null \")\n                if( grid[randRow][j]!==start|| grid[randRow][j]!==finish)\n\t\t\t\t grid[randRow][j].isWall=true\n                \n                \n\t\t\t}\n\t\t}\n\t\trecursiveDivMazeHelper(iStart, (randRow - 1), jStart, jEnd, horzStart, (randRow - 2), vertStart, vertEnd, walls, passages,start,finish); //up\n\t\trecursiveDivMazeHelper((randRow + 1), iEnd, jStart, jEnd, (randRow + 2), horzEnd, vertStart, vertEnd, walls, passages,start,finish); //down\n\t}\n\treturn\n\n}\n\nfunction createVisited(grid){\n\tvar visited = [];\n\t\n\tfor (var i = 0; i < grid.length; i++){\n\t\tvar row = [];\n\t\tfor (var j = 0; j < grid[0].length; j++){\n\t\t\tif (grid[i][j].isWall){\n\t\t\t\trow.push(true);\n\t\t\t} else {\n\t\t\t\trow.push(false);\n\t\t\t}\n\t\t}\n\t\tvisited.push(row);\n\t}\n\treturn visited;\n}\n        \n\n\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport Select from 'react-select'\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\nimport {astar, getNodesInShortestPathOrderAstar} from '../algorithms/astar1.js';\nimport {BFS,getNodesInShortestPathOrderBFS} from '../algorithms/bfs.js';\nimport {DFS,getNodesInShortestPathOrderDFS} from '../algorithms/dfs.js';\nimport {biDirectional,getNodesInShortestPathOrderBiDi} from '../algorithms/bidirectional.js';\n\n\nimport './PathfindingVisualizer.css';\nimport { binaryTreeMaze } from '../algorithms/binaryTreeMaze';\nimport { dfsMaze } from '../algorithms/dfsMaze';\n//import {recursiveDivision} from '../algorithms/recursiveDivision.js';\nimport {recursiveDivMaze} from '../algorithms/RecursiveDivisionMaze.js';\n\nlet START_NODE_ROW = 10;\nlet START_NODE_COL = 15;\nlet FINISH_NODE_ROW = 10;\nlet FINISH_NODE_COL = 35;\nlet visited=[]\nlet path=[]\nlet t1=0\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      moveStart: false,\n      moveEnd: false,\n      mazeType: \"selectMaze\",\n      algo:\"\",\n      algoInfo:\"\",\n      log:\"Please select a maze and/or algorithm\"\n    };\n    this.resetGrid=this.resetGrid.bind(this)\n    this.visualizeDijkstra=this.visualizeDijkstra.bind(this)\n    this.handleMazeChange=this.handleMazeChange.bind(this)\n     this.handleAlgoChange=this.handleAlgoChange.bind(this) \n     this.clearPath=this.clearPath.bind(this)\n     //this.visualizeDijkstra=this.visualizeAlgo.bind(this)\n  }\n\n  componentDidMount() {\n    \n    \n    const grid = getInitialGrid();\n    this.setState({grid});\n    /*const g=randomMaze(grid,grid[10][15],grid[10][35]);\n    this.setState({grid:g});*/\n  }\n\n  handleMouseDown(row, col) {\n    \n    if((START_NODE_ROW===row&&START_NODE_COL===col))\n      {\n        const newGrid = this.state.grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n          ...node,\n\n          isStart: false\n          \n        };\n        \n        newGrid[row][col] = newNode;\n        \n         this.setState({grid: newGrid,moveStart: true,mouseIsPressed: true})\n         \n         return\n      }\n       if(FINISH_NODE_ROW===row&&FINISH_NODE_COL===col)\n       {  \n\n        const newGrid = this.state.grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n          ...node,\n\n          isFinish: false\n          \n        };\n        \n        newGrid[row][col] = newNode;\n\n         this.setState({moveEnd: true,mouseIsPressed: true})\n         return\n       }\n    \n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n    \n     \n  }\n\n  handleMouseEnter(row, col) {\n    \n    if (this.state.moveStart||this.state.moveEnd||!this.state.mouseIsPressed) return;\n    \n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp(row,col) {\n    \n    if(this.state.moveStart)\n      {  \n          \n          const newGrid = getNewGridMovingStart(this.state.grid, row, col);\n           this.setState({grid: newGrid});\n           \n\n      }\n      if(this.state.moveEnd)\n      {   \n          \n          const newGrid = getNewGridMovingEnd(this.state.grid, row, col);\n            this.setState({grid: newGrid});\n            \n\n      }\n\n\n    this.setState({moveStart:false,moveEnd:false,mouseIsPressed: false});\n  }\n    \n   handleAlgoChange(event)\n   {   \n        this.clearPath();\n        \n       let string=\"\"\n       switch(event.target.value)\n    {\n      case \"Dijkstra's Algorithm\":{  \n          string=\"Dijkstra's Algorithm is weighted and guarantees the shortest path.\"\n          break;\n      }\n      case \"A* Search\":{\n           string=\"At each step,A* uses Heuristic distance to move on.\"\n        break;\n       }\n      case \"Breadth First Search\":{\n          string=\"Explores the nodes ,layer by layer.It Guarantees the shortest path. \"\n        break;\n       }\n      case \"Depth First Search\":{\n        string=\"Explores the node branch as far as possible prior to backtrack .\"\n        break;\n      }\n      case \"BiDirectional Search\":{\n        string=\"Simply,BFS from both directions.Does not guarantee shortest path\"\n        break;\n      }\n      default :{}\n    }\n\n        \n        this.setState({algo:event.target.value,algoInfo:string})\n        \n\n   }\n   visualizeAlgo()\n   {  \n    let d=new Date();\n    t1=d.getTime();\n    \n    switch(this.state.algo)\n    {\n      case \"Dijkstra's Algorithm\":{  \n          this.visualizeDijkstra()\n          break;\n      }\n      case \"A* Search\":{\n        this.visualizeAstar()\n        break;\n       }\n      case \"Breadth First Search\":{\n        this.visualizeBFS()\n        break;\n       }\n      case \"Depth First Search\":{\n        this.visualizeDFS();\n        break;\n      }\n      case \"BiDirectional Search\":{\n        this.visualizeBiDi()\n        break;\n      }\n      default :{}\n\n    }\n    \n\n\n   }\n\n\n  handleMazeChange(event){\n    \n    \n    console.log(event.target.value)\n    this.resetGrid();\n       \n    const Grid=getInitialGrid()\n     \n    \n      const {grid}=this.state\n     switch(event.target.value)\n     {\n       \n          case \"binaryTreeMaze\":{\n            \n            \n            const newGrid=binaryTreeMaze(Grid,Grid[START_NODE_ROW][START_NODE_COL],Grid[FINISH_NODE_ROW][FINISH_NODE_COL])\n            this.setState({grid:newGrid,mazeType:\"binaryTreeMaze\"})\n            break;\n          }\n          case \"dfsMaze\":{const newGrid=dfsMaze(Grid,Grid[START_NODE_ROW][START_NODE_COL],Grid[FINISH_NODE_ROW][FINISH_NODE_COL])\n            this.setState({grid:newGrid,mazeType:\"dfsMaze\"})\n            break;}\n\n           case \"recursiveDivision\":{  \n             const newGrid=recursiveDivMaze(Grid,null,Grid[START_NODE_ROW][START_NODE_COL],Grid[FINISH_NODE_ROW][FINISH_NODE_COL])\n            this.setState({grid:newGrid,mazeType:\"recursiveDivision\"})\n            break;}\n            case \"recursiveDivisionVerticalSkew\":{  \n              const newGrid=recursiveDivMaze(Grid,\"VERTICAL\",Grid[START_NODE_ROW][START_NODE_COL],Grid[FINISH_NODE_ROW][FINISH_NODE_COL])\n             this.setState({grid:newGrid,mazeType:\"recursiveDivision\"})\n             break;}\n             case \"recursiveDivisionHorizontalSkew\":{  \n              const newGrid=recursiveDivMaze(Grid,\"HORIZONTAL\",Grid[START_NODE_ROW][START_NODE_COL],Grid[FINISH_NODE_ROW][FINISH_NODE_COL])\n             this.setState({grid:newGrid,mazeType:\"recursiveDivision\"})\n             break;} \n             \n            \n            default: {}\n\n\n     }\n\n  }\n\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n        if(!visitedNodesInOrder||visitedNodesInOrder.length===0)\n          {\n            var d1=new Date();\n        var t2=d1.getTime();\n        \n        var dur=t2-t1;\n        var c1=\"Duration:\"+dur+\"ms.Path not found\"; \n        this.setState({log:c1});\n           return\n          }\n\n         \n    for (let i = 0; !!visitedNodesInOrder&&i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length&&nodesInShortestPathOrder.length>=2) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n          \n        var d1=new Date();\n        var t2=d1.getTime();\n        var p=nodesInShortestPathOrder.length===0?\"Path not found\":nodesInShortestPathOrder.length\n        var dur=t2-t1;\n        var c1=\"Duration:\"+dur+\"ms.Path: \"+p; \n        this.setState({log:c1});\n        \n        \n        \n        \n        return;\n      \n\n      }\n      setTimeout(() => {\n\n           \n        const node = visitedNodesInOrder[i];\n        if(!node)\n          return\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n          \n          \n          //visitedNodesInOrder[i].isExplored=true\n      }, 10 * i);\n\n\n      var d1=new Date();\n      var t2=d1.getTime();\n      var p=(nodesInShortestPathOrder.length===0)?\"Path not found\":nodesInShortestPathOrder.length\n      var dur=t2-t1;\n      var c1=\"Duration:\"+dur+\"ms.Path: \"+p; \n      this.setState({log:c1});\n\n\n\n    }\n    \n\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n          //nodesInShortestPathOrder[i].isPath=true\n      }, 50 * i);\n    }\n  }\n\n  clearPath(){\n    \n    const {grid}=this.state;\n    const g=JSON.parse(JSON.stringify(grid));\n    for(let i=0;i<grid.length;i++)\n    for(let j=0;j<grid[0].length;j++)\n    {  \n      document.getElementById(`node-${i}-${j}`).classList.remove('node-visited')\n      document.getElementById(`node-${i}-${j}`).classList.remove('node-shortest-path')\n    }\n      \n   /* for(let i=0;i<grid.length;i++)\n    for(let j=0;j<grid[0].length;j++)\n    {   \n      if(grid[i][j].isStart)\n      {g[i][j].isStart=true\n        g[i][j].isWall=false\n        continue\n      }\n      if(grid[i][j].isFinish)\n      {g[i][j].isfinish=true\n        g[i][j].isWall=false\n        continue\n      }\n      \n      if(grid[i][j].isWall)\n          g[i][j].isWall=true\n\n    } */\n\n\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className='node node-start'\n      document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className='node node-finish'\n\n         //g[START_NODE_ROW][START_NODE_COL].isStart=true\n         //g[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish=true\n\n    //g[START_NODE_ROW][START_NODE_COL].isWall=false;\n    //g[FINISH_NODE_ROW][FINISH_NODE_COL].isWall=false;\n    // g[START_NODE_ROW][START_NODE_COL].isStart=true;\n     //g[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish=true;\n      \n     const Grid =[]\n  \n     for (let row = 0; row <=20; row++) {\n       const currentRow = [];\n       for (let col = 0; col <=50; col++) {\n          \n        const n= createNode(col, row)\n         \n        currentRow.push(n);\n       }\n       Grid.push(currentRow);\n     }  \n\n\n     for(let i=0;i<Grid.length;i++)\n     for(let j=0;j<Grid[0].length;j++)\n     {   \n      \n       if(grid[i][j].isWall)\n           Grid[i][j].isWall=true\n \n     }\n\n\n     this.setState({grid:Grid});\n\n    \n  }\n  \n  resetGrid(){\n      \n    const {grid} = this.state;\n     const g=JSON.parse(JSON.stringify(grid)).slice();\n     for(let i=0;i<visited.length;i++)\n         {const node=visited[i]\n          \n            document.getElementById(`node-${node.row}-${node.col}`).classList.remove('node-visited')\n             \n        }\n        for(let i=0;i<path.length;i++)\n         {\n          const node=path[i]\n          \n          document.getElementById(`node-${node.row}-${node.col}`).classList.remove('node-shortest-path')\n              \n        }\n         \n\n     \n     \n   document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className='node node-start'\n       document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className='node node-finish'\n\n         g[START_NODE_ROW][START_NODE_COL].isStart=true\n         g[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish=true\n\n\n         const Grid =[]\n  \n         for (let row = 0; row <=20; row++) {\n           const currentRow = [];\n           for (let col = 0; col <=50; col++) {\n             const n= createNode(col, row)\n             //document.getElementById(`node-${n.row}-${n.col}`).classList.remove('node-shortest-path')\n            currentRow.push(n);\n           }\n           Grid.push(currentRow);\n         }  \n         const g1=getInitialGrid()\n         let x=\"Please select a maze and/or algorithm\"\n\n        this.setState({grid:Grid,mazeType:\"selectMaze\",algo:\"\",algoInfo:\"\",log:x});\n     \n  }\n\n\n  visualizeDijkstra() {\n    const {grid} = this.state;\n    \n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      //visitedNodesInOrder=[]\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n         visited=visitedNodesInOrder.slice()\n       \n     const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n           path=nodesInShortestPathOrder\n         if(nodesInShortestPathOrder.length===1)\n             nodesInShortestPathOrder.shift();\n\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    \n         \n  }\n  visualizeAstar() {\n    const {grid} = this.state;\n    \n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      //visitedNodesInOrder=[]\n    const visitedNodesInOrder = astar(grid, startNode, finishNode);\n         visited=visitedNodesInOrder.slice()\n         console.log(visitedNodesInOrder.length)\n       \n     const nodesInShortestPathOrder = getNodesInShortestPathOrderAstar(finishNode);\n           path=nodesInShortestPathOrder\n             \n\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    \n  }\n  visualizeBFS() {\n    const {grid} = this.state;\n    \n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      //visitedNodesInOrder=[]\n    const visitedNodesInOrder = BFS(grid, startNode, finishNode);\n         visited=visitedNodesInOrder.slice()\n       \n     const nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode);\n           path=nodesInShortestPathOrder\n     \n\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    \n  }\n  visualizeDFS() {\n    const {grid} = this.state;\n    \n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      //visitedNodesInOrder=[]\n    const visitedNodesInOrder = DFS(grid, startNode, finishNode);\n         visited=visitedNodesInOrder.slice()\n       \n     const nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode);\n           path=nodesInShortestPathOrder\n     \n\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    \n  }\n  visualizeBiDi() {\n    const {grid} = this.state;\n    \n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n      //visitedNodesInOrder=[]\n    const visitedNodesInOrder = biDirectional(grid, startNode, finishNode);\n          if(!visitedNodesInOrder)\n              console.log(\"Im the null pointer\")\n         visited=visitedNodesInOrder.slice()\n       \n     const nodesInShortestPathOrder = getNodesInShortestPathOrderBiDi(finishNode);\n           path=nodesInShortestPathOrder\n     \n\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    \n  }\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n    return (\n      <div className=\"Wrapper\" >\n         <h1>\n           <p1 className=\"title\">My Visualizer</p1>\n             <ul>\n         <li><button className=\"btnReset\" onClick={()=>this.resetGrid()}>Clear Grid</button></li>\n           \n          <li>\n            <div className=\"algo-container\">\n            <select className=\"selectAlgo\"  value={this.state.algo}  onChange={(event)=>{this.handleAlgoChange(event)}}>\n           \n           <option value=\"\" >Algorithms</option>\n           <option value=\"Dijkstra's Algorithm\" >Dijkstra's Algorithm</option>\n           <option value=\"A* Search\" >A* Search</option>\n           <option value=\"Breadth First Search\" >Breadth First Search</option>\n           <option value=\"Depth First Search\" >Depth First Search</option>\n           <option value=\"BiDirectional Search\" >BiDirectional Search </option>\n           \n           </select>\n           </div>\n           </li>\n           \n         \n       <li><button  className=\"btnVisualize\" onClick={() => this.visualizeAlgo()}>\n          {`Visualize ${this.state.algo} Algorithm`}\n        </button></li>\n        <li><button className=\"clearPath\" onClick={()=>this.clearPath()}>Clear Path</button></li>\n        <p2 className=\"algoInfo\">{` ${this.state.algoInfo} `}</p2>\n          <li className=\"startNode\">s</li><li className=\"start\">Start </li>\n          <li className=\"targetNode\">t</li><li className=\"target\">Target </li>\n          <li className=\"visitedNode\">v</li><li className=\"visited\">Visited </li>\n          <li className=\"pathNode\">p</li><li className=\"path\">Shortest Path </li>\n          <li className=\"wallNode\">w</li><li className=\"wall\">Wall </li>\n          <li className=\"result\">^</li>\n          <li className=\"log\">{` ${this.state.log} `}</li>\n\n          <div >\n         <li> <select className=\"selectMaze\" value={this.state.mazeType} onChange={(event)=>this.handleMazeChange(event)}>\n          <option value=\"selectMaze\">Mazes</option>\n          <option value=\"binaryTreeMaze\">BinaryTreeMaze</option>\n          <option value=\"dfsMaze\">DFSmaze</option>\n          <option value=\"recursiveDivision\">Recursive Division</option>\n          <option value=\"recursiveDivisionVerticalSkew\">Recursive Division(Vertical Skew)</option>\n          <option value=\"recursiveDivisionHorizontalSkew\">Recursive Division(Horizontal Skew)</option>\n          </select></li>\n          </div>\n          </ul>\n          \n          </h1>\n\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx} className=\"rowWrapper\">\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall,isVisited,otherVisited,previousNode,previousNodeStart\n                  ,previousNodeEnd,f,g,h,} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      isVisited={isVisited}\n                      otherVisited={otherVisited}\n                      previousNode={previousNode}\n                      previousNodeStart={previousNodeStart}\n                      previousNodeEnd={previousNodeEnd}\n                      f={f}\n                      g={g}\n                      h={h}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>this.handleMouseEnter(row, col)}\n                      onMouseUp={(row,col) => this.handleMouseUp(row,col)}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        \n\n      </div>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  \n  for (let row = 0; row <=20; row++) {\n    const currentRow = [];\n    for (let col = 0; col <=50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    otherVisited: false,\n    isWall: false,\n    previousNode: null,\n    previousNodeStart: null,\n    previousNodeEnd: null,\n    f:Infinity,\n    g:0,\n    h:Infinity,\n    \n    \n   \n  };\n};\n\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  \n\n  \n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  \n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridMovingStart = (grid, row, col) => {\n   \n  START_NODE_ROW=row\n  START_NODE_COL=col\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall:false,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    \n  };\n  \n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridMovingEnd = (grid, row, col) => {\n  \n  FINISH_NODE_ROW=row\n  FINISH_NODE_COL=col\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall:false,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\n      \n\n\t\n\n\n","export function binaryTreeMaze(grid,startNode,finishNode){\n   let height=grid.length\n   let width=grid[0].length\n   const newGrid=grid.slice()\n   \n   for(let i=0;i<height;i=i+2)\n   {  for(let j=0;j<width;j=j+2)\n      {     \n           \n           const node=newGrid[i][j]\n           const n1={\n               ...node,\n               isWall:grid[i][j]!==startNode&&grid[i][j]!==finishNode?true:false,\n           };\n           newGrid[i][j]=n1\n\n\n            let prob=Math.random()\n            \n           if((i-1>=0&&prob>0.5)||(i-1>=0&&j-1<0))\n             {\n                const node1=newGrid[i-1][j]\n             \n                const n2={\n                    ...node1,\n                    isWall:grid[i-1][j]!==startNode&&grid[i-1][j]!==finishNode?true:false,\n                };\n                newGrid[i-1][j]=n2\n\n             }\n            if((j-1>=0&&prob<=0.5)||i-1<0&&j-1>=0)\n                {  \n                    const node2=newGrid[i][j-1]\n\n                    const n3={\n                        ...node2,\n                        isWall:grid[i][j-1]!==startNode&&grid[i][j-1]!==finishNode?true:false,\n                    };\n                    newGrid[i][j-1]=n3\n\n                }\n\n                \n\n           \n      }\n\n   }\n   return newGrid;\n\n}\n\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}